#!/usr/bin/python3

# GrblGru lathe V1.0 usually generates finish cuts with segments
# post process to smooth it out with curve fit

# can be applied multiple times

# what if gcode unit=inch ?
# todo: avoid curve fit when large and small sloped        

import struct
import sys
import getopt
import re

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import UnivariateSpline

xbs = 0.0      # x-axis backlash (z-axis is not critical for lathe)
zmin = -1e6    # regoin to be smoothed
zmax = -1e6 

def usage(prog, exit_stat=0):
    str = 'Usage: %s [-x xbkls] [-r zmin:zmax] gcode\n' % prog
    str += \
'''  -x xbkls
     [experimental] specify x-axis backlash uit= mm, default = 0.0
  -r zmin:zmax
     specify the region to be smoothed
'''
    if exit_stat != 0: sys.stderr.write(str)
    else:              sys.stdout.write(str)
    sys.exit(exit_stat)


def back2start(ltxt):
    # GrblGru diff versoins have different style of comments
    if re.findall( r'gcodebacktostart', ltxt) or \
       re.findall( r'back to start', ltxt, flags=re.IGNORECASE) :
        return True
    else:
        return False

def not_finish(ltxt):
    if re.findall( r'active =', ltxt, flags=re.IGNORECASE) :
        return True
    else:
        return False 

#-----------------------------------------------------------------------------

try:
    opts, args = getopt.getopt(sys.argv[1:], 'hx:r:')
except:
    usage(sys.argv[0], 1)
    
if len(args) == 0:
    usage(sys.argv[0], 1)

for opt, val in opts:
    if opt in ( '-h', '--help'):
        usage( sys.argv[0], 0 )
    elif opt in ('-x'):
        xbs = float(val)
    elif opt in ('-r'):
        rx = [-abs(float(i)) for i in val.split(":")]
        zmax = max(rx)
        zmin = min(rx)

gcfile = open( args[0], 'r')
Lines = gcfile.readlines()
gcfile.close()

if not re.findall( r'GrblGru', Lines[0]) :
    print("ERROR: file %s is not a g-code generated by GrblGru" % args[0], file=sys.stderr )
    sys.exit(2)

#--------------------------------------------------------------------------------------------
# figure out boundary box
#--------------------------------------------------------------------------------------------

xold = 0.0
xnew = 0.0

zold = 0.0
znew = 0.0

rx=[]
rz=[]
fx=[]
fz=[]

fin=[]

for line in Lines:

    if not_finish(line):  fin=[]

    xpos = re.findall( r'[X](.?\d+.\d+)', line)
    if xpos:
        xold = xnew
        xnew = float( xpos[0])
        
    zpos = re.findall( r'[Z](.?\d+.\d+)', line)
    if zpos:
        zold = znew
        znew = float( zpos[0])

    nline =  line.strip()

    if xpos or zpos :
        if fin :
            fx.append( xnew )
            fz.append( znew )
        else :
            rx.append( xnew )
            rz.append( znew )

    if not fin :
        fin = re.findall( r'( Finish )', line )
        
#----------------------------------------------------------------------------------------------

xmin = min( min(fx), min(rx) )
xmax = max( max(fx), max(rx) )

zmin = min( min(fz), min(rz) )
zmax = max( max(fz), max(rz) )

print(  'g-code limit : Z=[%.3f, %.3f]  X= [%.3f, %.3f]' % ( zmin, zmax, xmin, xmax) )

zs1 = 0
zs2 = 0

bidx = 0
bnd = [[], []]

def mouse_event1(event):
    print(  'Z= %8.3f  X= %8.3f' % (event.xdata, event.ydata))
    global zs1, bidx, bnd
    zs1 = event.xdata

    if bnd[bidx] : bnd[bidx].remove()
    bnd[bidx], = plt.plot( [event.xdata, event.xdata], [xmin, xmax], 'r-', lw=1)
    bidx += 1
    if bidx > 1 : bidx = 0
    #plt.show()  #segmentatio fault !

def mouse_event2(event):
    print(  'Z= %8.3f  X= %8.3f' % (event.xdata, event.ydata))
    global zs2
    zs2 = event.xdata

def on_key(event):
    if event.key == 'S' :
        print('smooth range = ', zs1,  zs2)

    
fig = plt.figure()
cid = fig.canvas.mpl_connect('button_press_event', mouse_event1)
cid = fig.canvas.mpl_connect('button_release_event', mouse_event2)
cid = fig.canvas.mpl_connect('key_press_event', on_key)

plt.gca().invert_yaxis()
plt.plot( rz, rx, 'b-', lw=1)
plt.plot( fz, fx, 'g.-', lw=1)
plt.show()

