#!/usr/bin/python3

# GrblGru lathe V1.0 usually generates finish cuts with segments
# post process to smooth it out with curve fit

# can be applied multiple times

# what if gcode unit=inch ?
# todo: avoid curve fit when large and small sloped        

import struct
import sys
import getopt
import re

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import UnivariateSpline

xbs = 0.0      # x-axis backlash (z-axis is not critical for lathe)
zmin = -1e6    # regoin to be smoothed
zmax = -1e6 

def usage(prog, exit_stat=0):
    str = 'Usage: %s [-x xbkls] [-r zmin:zmax] gcode\n' % prog
    str += \
'''  -x xbkls
     [experimental] specify x-axis backlash uit= mm, default = 0.0
  -r zmin:zmax
     specify the region to be smoothed
'''
    if exit_stat != 0: sys.stderr.write(str)
    else:              sys.stdout.write(str)
    sys.exit(exit_stat)


def back2start(ltxt):
    # GrblGru diff versoins have different style of comments
    if re.findall( r'gcodebacktostart', ltxt) or \
       re.findall( r'back to start', ltxt, flags=re.IGNORECASE) :
        return True
    else:
        return False

def not_finish(ltxt):
    if re.findall( r'active =', ltxt, flags=re.IGNORECASE) :
        return True
    else:
        return False 

#-----------------------------------------------------------------------------

try:
    opts, args = getopt.getopt(sys.argv[1:], 'hx:r:')
except:
    usage(sys.argv[0], 1)
    
if len(args) == 0:
    usage(sys.argv[0], 1)

for opt, val in opts:
    if opt in ( '-h', '--help'):
        usage( sys.argv[0], 0 )
    elif opt in ('-x'):
        xbs = float(val)
    elif opt in ('-r'):
        rx = [-abs(float(i)) for i in val.split(":")]
        zmax = max(rx)
        zmin = min(rx)

gcfile = open( args[0], 'r')
Lines = gcfile.readlines()
gcfile.close()

if not re.findall( r'GrblGru', Lines[0]) :
    print("ERROR: file %s is not a g-code generated by GrblGru" % args[0], file=sys.stderr )
    sys.exit(2)

#--------------------------------------------------------------------------------------------
# figure out boundary box
#--------------------------------------------------------------------------------------------

xold = 0.0
xnew = 0.0

zold = 0.0
znew = 0.0

rx=[]
rz=[]
fx=[]
fz=[]

fin=[]

for line in Lines:

    if not_finish(line):  fin=[]

    xpos = re.findall( r'[X](.?\d+.\d+)', line)
    if xpos:
        xold = xnew
        xnew = float( xpos[0])
        
    zpos = re.findall( r'[Z](.?\d+.\d+)', line)
    if zpos:
        zold = znew
        znew = float( zpos[0])

    nline =  line.strip()

    if xpos or zpos :
        if fin :
            fx.append( xnew )
            fz.append( znew )
        else :
            rx.append( xnew )
            rz.append( znew )

    if not fin :
        fin = re.findall( r'( Finish )', line )

        
#----------------------------------------------------------------------------------------------

plt.gca().invert_yaxis()
plt.plot( rz, rx, 'b-', lw=1)
plt.plot( fz, fx, 'g.-', lw=1)
plt.show()

